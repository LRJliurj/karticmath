1 梯度直方图（HOG histogram of oriented gradient）
HOG 描述符是一个特征描述符，因此HOG与SIFT ,SURF,ORB 属于同一类型的描述符。
在图像和视频处理中常常会进行目标检测，其内部机制都差不多： 将图像划分成多个部分，并计算各个部分的梯度。 比如：用于人脸检测的LBPH描述符

HOG不是基于颜色值而是基于梯度来计算直方图的。HOG所得到的特征描述符能够为特征匹配和目标检测（或目标识别）提供重要的信息。

    以卡车为例：HOG提取图片特征，卡车图像被分成小单元，每个小单元是16*16的像素块，每个单元都包含了视觉表示。该视觉表示是按八个方向（
N,NW,W,SW,S,SE,E和NE）所计算的颜色梯度。 每个单元的八个图就为直方图，因此每个单元都会有唯一的标识。
    将直方图外推成描述符是相当复杂的过程。首先计算每个单元的局部直方图 ，这些单元会合成较大的区域，也称为块。 块可以由任意多个单元组成，
但Dalal和Triggs（HOG的发明人） 发现当进行 行人检测时，一个块包含2*2的单元时可以得到最好的效果。 按块来构成特征向量是为了便于归一化，同时也考虑
到了光照和阴影的变化（一个单元的区域太小，不能检测到这样的变化）。 这样做减少了图像与块之间光照和阴影的差异，从而提高了检测精度。


大多数情况下： 仅仅比较两幅图像的单元是行不通的，除非这两幅图像完全一样（从大小和数据2方面）
还有2个问题需要解决：位置 和 尺度

1 尺度问题
例如：要检测的目标（比如自行车）是较大图像中的一部分，要对两幅图像进行比较。如果在比较过程中找不到一组相同的梯度，则检测就会失败（即使两幅图像都有自行车）

2 位置问题
    要检测的目标可能位于图像的任何地方，所以需要扫描图像的各个部分，以确保能找到感兴趣的区域。 并且在这些区域中去尝试检测目标。 即使待检测图像中的目标和训练图像中的
目标一样大，也需要通过某种方式OpenCv定位到该目标。因此，只对有可能存在目标的区域进行比较，而该图像的其余部分会被舍弃。

解决上面两个问题：
（1）图像金字塔
    计算机视觉中很多算法会用到图像金字塔的概念，图像金字塔是图像的多尺度表示。 （粗粒度 中粒度 细粒度）
图像的多尺度表示（或图像金字塔）有助于解决不同尺度下的目标检测问题。 比如要识别的目标正好与训练数据集中的数据集中的目标有相同的尺度。

目标分类器（这个功能可以由OpenCv来检测目标），可通过训练这个分类器，训练需要的图像数据库，这个数据库由正匹配（positive match）和负匹配（negative match）
构成，注意：在整个训练数据集的正匹配中同一目标不可能都一样大。 这就是需要构建图像金字塔的原因。

构建图像金字塔的过程：
  a , 获取图像
  b , 使用任意尺度的参数来调整（缩小）图像的大小
  c , 平滑图像 （使用高斯模糊）
  d , 如果图像的比最小尺寸还大，重复整个过程。

  CascadeClassifier 对象使用的detectMultiScale（）函数的scaleFactor 参数表示一个比率，即每层金字塔中所获得的图像与上一层图像的比率。
  scaleFactor参数越小，金字塔层数越多，计算更慢，计算量加大。会有较为准确的结果。

（2）滑动窗口
    滑动窗口是用于计算机视觉的一种技术，它包括图像中要移动部分（滑动窗口）的检查以及使用图像金字塔对各部分进行检测。 为了在多尺度下检测对象。
滑动窗口通过扫描较大图像的较小区域来解决定位问题，进而在同一图像的不同尺度下重复扫描。 这种技术需要将每副图像分解成多个部分，然后丢掉那些不太可能
包含对象的部分，并对剩余部分进行分类。
    使用这一方法会有一个问题：区域重叠
    每个窗口每次都会丢掉（slide off）几个像素，这意味着一个滑动窗口可以对同一张人脸的四个不同位置进行正匹配。当然，只需要一个匹配结果，而不是4个。
此外，对良好评分的图像区域不感兴趣，而是对有最高评分的图像区域感兴趣。
    这里引入另一个问题：非最大抑制 。 它是指给定一组重叠区域，可以用最大评分来抑制所有未分类的区域。

（3） 非最大（或非极大）抑制
    非最大（或非极大）抑制是一种与图像同一区域相关的所有结果进行抑制的技术 ，这些区域没有最大评分。这是因为同样排放的窗口往往具有更高的评分， 并且重叠区域会变得
明显，但是这里只关心结果最好的窗口，并丢弃评分较低的重叠窗口。
    当采用滑动窗口检测图像时，要从一系列窗口中保留最佳窗口，并且所有重叠都是围绕着同一主题进行的。
    为此，大于阈值x的所有窗口都要进行非最大抑制操作。

    往往将滑动窗口与图像金字塔结合在一起对图像进行处理。 这意味着将在不同尺度下获得一系列的窗口， 然后，用于在原始尺度下进行检测相同的方法来计算较小尺度
下的窗口大小。最后把这个窗口号与原始窗口放在一起。
该过程已经有人实现 最快的算法：Tomasz Malisiewicz 博士实现的 http://www.computervisionblog.com/2011/08/blazing-fast-nmsm-form-exemplar-svm.html

实现非最大抑制过程：
    a , 一旦建立图形金字塔，为了检测目标，可采用滑动窗口来搜索图像。
    b , 收集当前所有含有目标的窗口（超出一旦任意阈值），并得到最高响应的窗口W。
    c , 消除所有与W有明显重叠的窗口。
    d , 移动到下一个有最高响应的窗口，在当前尺度下重复上述过程 。

再这个过程完成后，移动图像金字塔的下一尺度 ， 并重复前面的过程。 为了确保窗口在整个非最大抑制过程结束时能正确的表示，一定要计算相对于
图像原始尺寸的窗口大小（例如 ，在金字塔中，如果在只有原始尺寸50%的尺度下检测一个窗，那么检测的窗口实际上是原始图像大小的1/4）

    上述过程结束后， 会得到一系列评分最高的窗口。另外，可以检测完全包含在其他窗口中的窗口 （列如代码中，人检测过程） 并消除这些窗口。

    如何确定窗口的评分？  需要一个分类系统来确定某一个特征是否存在，并且对这种分类会有一个置信度评分， 这里采用支持向量机（SVM）来分类。
（SVM的最优超平面是目标检测的重要组成部分，用来区分哪些像素是目标，哪些像素不是目标）


思考：
   使用內建的人脸或人检测很容易得到应用原型， 但如何得到人检测的特征，及如何用于其它目标的检测（如车牌，车）
   对于不同的检测目标如何构建分类器？
   使用SVM和词袋技术（bag-of-word,BOW）


（1） 词袋
    词袋（BOW）的概念最初并不是针对计算机视觉的，但计算机视觉会使用该概念的升级版。最初词袋的概念源于语言分析和信息检索领域 。

    自然语言中的词袋：
    BOW用来在一系列文档中计算每个词出现的次数，然后，用这些次数构成向量来重新表示文档。 比如：
    a, i like opencv and i like python
    b, i like java and python
    c, i dont like arichokes

    字典 ：
    i : 4
    like : 4
    opencv : 2
    and :2
    python:2
    java :1
    dont 1
    artichokes :1

    使用上述字典
    a,b,c 三个文档的向量表示
    [2,2,1,1,1,0,0,0]
    [1,1,0,1,1,1,0,0]
    [1,1,0,0,0,0,1,1]

    这些向量可以看成文档的直方图表示或被当做特征 ， 这些特征可以被用来训练分类器。

    计算机视觉中的词袋（BOW）实现过程：
    1) 取一个样本数据集
    2） 对数据集中的每幅图像提取描述符（采用SIFT,SUFT等方法）
    3） 将每一个描述符都添加到BOW训练器中。
    4） 将描述符聚类到k簇中（聚类的中心就是视觉单词）
    这个过程需要提供视觉单词字典。

    BagOfWordsKMeansTrainer 是一种用于执行目标检测的类。